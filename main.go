package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"unicode"

	"github.com/dave/jennifer/jen"
)

// TODO(jfm): robust package name detection.
// TODO(jfm): avoid duplicate method definitions; fluent method may already be
// defined by author.

func main() {
	if err := func() error {
		var (
			// path to directory containing go files.
			path string
			// out path to generated file eg "fluent.go".
			out string
			// w is the output writer. Points to stdout when no output file is specified.
			w io.Writer
		)
		if len(os.Args) > 1 {
			path = os.Args[1]
		}
		if len(os.Args) > 2 {
			out = os.Args[2]
		}
		if path == "" {
			return fmt.Errorf("specify directory path")
		}
		if out == "" {
			w = os.Stdout
		} else {
			outf, err := os.Create(out)
			if err != nil {
				return fmt.Errorf("creating output file: %w", err)
			}
			defer outf.Close()
			w = outf
		}
		entries, err := ioutil.ReadDir(path)
		if err != nil {
			return fmt.Errorf("reading dir: %w", err)
		}
		file := jen.NewFile(strings.Split(filepath.Base(path), ".")[0])
		file.PackageComment("// Code generated by go generate; DO NOT EDIT.")
		var (
			// Imports maps import names to fully qualified import paths.
			// ImportVisitor walks the ast and collects the imports.
			imports = map[string]string{}
		)
		for _, entry := range entries {
			if entry.IsDir() {
				continue
			}
			if filepath.Ext(entry.Name()) != ".go" {
				continue
			}
			if strings.Contains(entry.Name(), "fluent") {
				continue
			}
			src, err := ioutil.ReadFile(filepath.Join(path, entry.Name()))
			if err != nil {
				return fmt.Errorf("reading in source code: %w", err)
			}
			f, err := parser.ParseFile(token.NewFileSet(), "", src, parser.ParseComments)
			if err != nil {
				return fmt.Errorf("parsing file: %w", err)
			}
			ast.Walk(ImportVisitor{Map: &imports}, f)
			ast.Walk(StructVisitor{Suffix: "Style", Callback: func(s Struct) {
				for _, field := range s.Fields {
					var argument string
					for _, c := range field.Identifer {
						if unicode.IsUpper(c) {
							argument += strings.ToLower(string(c))
						}
					}
					// TODO(jfm): handle pointer identifiers.
					var ident = jen.Id(argument).Id(field.Type)
					if parts := strings.Split(field.Type, "."); len(parts) > 1 {
						fullyQualified, ok := imports[parts[0]]
						if !ok {
							ident = jen.Id(argument).Qual(parts[0], parts[1])
						} else {
							ident = jen.Id(argument).Qual(fullyQualified, parts[1])
						}
					}
					if field.DocComment != "" {
						for _, comment := range strings.Split(field.DocComment, "\n") {
							file.Comment(comment)
						}
					}
					file.Func().
						Params(jen.Id("style").Id(s.Type)).
						Id(fmt.Sprintf("With%s", field.Identifer)).
						Call(ident).
						Id(s.Type).
						Block(
							jen.Id("style").Dot(field.Identifer).Op("=").Id(argument),
							jen.Return(jen.Id("style")),
						)
				}
			}}, f)
		}
		if _, err := fmt.Fprintf(w, "%#v\n", file); err != nil {
			return fmt.Errorf("writing output: %w", err)
		}
		return nil
	}(); err != nil {
		fmt.Printf("error: %v", err)
	}
}

// StructVisitor visits struct definitions on an ast.
type StructVisitor struct {
	// Suffix to match against. Could use regex for more generic approach.
	Suffix string
	// Callback is invoked for each struct definition.
	Callback func(Struct)
}

// Struct specifies a struct definition.
type Struct struct {
	Type   string
	Fields []Field
}

// Field specifies a struct field definition.
type Field struct {
	Type       string
	Identifer  string
	DocComment string
}

// Visit extracts data from struct definitions in the ast.
// Callback is invoked for each definition.
func (sv StructVisitor) Visit(n ast.Node) ast.Visitor {
	if sv.Callback == nil {
		return nil
	}
	t, ok := n.(*ast.TypeSpec)
	if !ok {
		return sv
	}
	if !strings.HasSuffix(t.Name.String(), sv.Suffix) {
		return sv
	}
	obj, ok := t.Type.(*ast.StructType)
	if !ok {
		return sv
	}
	var fields []Field
	for _, field := range obj.Fields.List {
		if isEmbedded := len(field.Names) == 0; isEmbedded {
			continue
		}
		for _, ident := range field.Names {
			if !ident.IsExported() {
				continue
			}
			var ft string
			if ptr, ok := field.Type.(*ast.StarExpr); ok {
				ft = "*"
				field.Type = ptr.X
			}
			switch n := field.Type.(type) {
			case *ast.Ident:
				ft += n.Name
			case *ast.SelectorExpr:
				if pkg, ok := n.X.(*ast.Ident); ok {
					ft += fmt.Sprintf("%s.%s", pkg.Name, n.Sel.Name)
				}
			}
			fields = append(fields, Field{
				Type:       ft,
				Identifer:  ident.Name,
				DocComment: strings.TrimSpace(field.Doc.Text()),
			})
		}
	}
	sv.Callback(Struct{
		Type:   t.Name.String(),
		Fields: fields,
	})
	return sv
}

// ImportVisitor collects imports into a map.
// Map is a pointer because it outlives the visitor instance, across runs for
// instance.
type ImportVisitor struct {
	Map *map[string]string
}

func (v ImportVisitor) Visit(n ast.Node) ast.Visitor {
	if v.Map == nil {
		return nil
	}
	im, ok := n.(*ast.ImportSpec)
	if !ok {
		return v
	}
	var (
		name = name(base(im.Path.Value))
		path = clean(im.Path.Value)
	)
	if im.Name != nil {
		name = im.Name.Name
	}
	var p string
	for ii, fragment := range strings.Split(path, "/") {
		if ii > 0 {
			p += "/"
		}
		p += fragment
		(*v.Map)[name] = p
	}
	return v
}

// base returns the final fragment in an import path.
func base(p string) string {
	fragments := strings.Split(clean(p), "/")
	return fragments[len(fragments)-1]
}

// clean strips the quotes off a path.
func clean(p string) string {
	return strings.Trim(p, `"`)
}

// name applies go conventions when importing a path with symbols in it.
// Any characters after '.' and '-' are ignored.
func name(p string) string {
	if idx := strings.LastIndex(p, "."); idx > 0 {
		p = p[:idx]
	}
	if idx := strings.LastIndex(p, "-"); idx > 0 {
		p = p[:idx]
	}
	return p
}
